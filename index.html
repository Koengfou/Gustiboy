<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smiley vs Kakskes</title>
  <style>
    html,body {
      margin: 0;
      padding: 0;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      background: #222;
      border: 2px solid #444;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup",   e => keys[e.key] = false);

const SMILEY_SIZE = 40;
const SPEED_INCREMENT = 0.15;
const MAX_VERTICAL_SPD = 5;
const poopObstacles = [];
let score = 0;
let gameOver = false;
let scoreTimer;

const player = {
  x: canvas.width / 2 - SMILEY_SIZE / 2,
  y: canvas.height - SMILEY_SIZE * 1.5,
  width : SMILEY_SIZE,
  height: SMILEY_SIZE,
  speed : 3,
  verticalSpeed: 1,
  emoji : "üòä"
};

const centerCircle = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  radius: 50
};

// ‚≠ï Collision helpers
function distance(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return Math.hypot(dx, dy);
}
function circleCircleOverlap(x1, y1, r1, x2, y2, r2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  const distSq = dx * dx + dy * dy;
  const rSum = r1 + r2;
  return distSq < rSum * rSum;
}
function rectCircleCollision(rect, circle) {
  const rectCX = rect.x + rect.width / 2;
  const rectCY = rect.y + rect.height / 2;
  const circleCX = circle.x + circle.size / 2;
  const circleCY = circle.y + circle.size / 2;
  const radius = circle.size / 2;

  const dx = Math.abs(circleCX - rectCX);
  const dy = Math.abs(circleCY - rectCY);

  if (dx > rect.width / 2 + radius) return false;
  if (dy > rect.height / 2 + radius) return false;
  if (dx <= rect.width / 2) return true;
  if (dy <= rect.height / 2) return true;

  const cornerDistSq = (dx - rect.width / 2) ** 2 + (dy - rect.height / 2) ** 2;
  return cornerDistSq <= radius * radius;
}

// üí© Spawn zonder overlap
function spawnPoopObstacle() {
  const maxTries = 20;
  let tries = 0;
  let valid = false;
  let newPoop;

  while (!valid && tries < maxTries) {
    const scale = Math.random() * 2 + 1; // schaal 1‚Äì3
    const size = SMILEY_SIZE * scale;
    const x = Math.random() * (canvas.width - size);
    const y = Math.random() * ((canvas.height * 0.75) - size);
    newPoop = { x, y, size, emoji: "üí©" };

    const overlapsScoreCircle = circleCircleOverlap(
      centerCircle.x, centerCircle.y, centerCircle.radius,
      x + size / 2, y + size / 2, size / 2
    );

    const overlapsOtherPoops = poopObstacles.some(p =>
      circleCircleOverlap(
        p.x + p.size / 2, p.y + p.size / 2, p.size / 2,
        x + size / 2, y + size / 2, size / 2
      )
    );

    if (!overlapsScoreCircle && !overlapsOtherPoops) valid = true;
    tries++;
  }

  if (valid) poopObstacles.push(newPoop);
}

// üîÅ Game flow
function movePlayer() {
  if (keys["ArrowLeft"] || keys["a"]) player.x -= player.speed;
  if (keys["ArrowRight"] || keys["d"]) player.x += player.speed;

  player.y -= player.verticalSpeed;

  if (player.y + player.height < 0) {
    player.y = canvas.height;
    player.x = Math.random() * (canvas.width - player.width);
    const n = Math.floor(Math.random() * 2) + 1;
    for (let i = 0; i < n; i++) spawnPoopObstacle();

    player.verticalSpeed = Math.min(player.verticalSpeed + SPEED_INCREMENT, MAX_VERTICAL_SPD);
  }

  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
}

function checkCollisions() {
  const cx = player.x + player.width / 2;
  const cy = player.y + player.height / 2;

  if (distance(cx, cy, centerCircle.x, centerCircle.y) < centerCircle.radius + player.width / 2)
    return true;

  return poopObstacles.some(p => rectCircleCollision(player, p));
}

function drawPlayer() {
  ctx.font = "32px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(player.emoji, player.x + player.width / 2, player.y + player.height / 2);
}

function drawPoops() {
  for (const o of poopObstacles) {
    ctx.font = `${o.size}px Arial`;
    ctx.fillText(o.emoji, o.x + o.size / 2, o.y + o.size / 2);
  }
}

function drawScoreCircle() {
  ctx.beginPath();
  ctx.fillStyle = "red";
  ctx.arc(centerCircle.x, centerCircle.y, centerCircle.radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "white";
  ctx.font = "24px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(score, centerCircle.x, centerCircle.y);
}

function showGameOver() {
  ctx.fillStyle = "rgba(0,0,0,.6)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.font = "40px Arial";
  ctx.textAlign = "center";
  ctx.fillText("üíÄ Game Over", canvas.width / 2, canvas.height / 2 - 40);
  ctx.font = "24px Arial";
  ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2);
  ctx.fillText("Druk op ENTER om opnieuw te spelen", canvas.width / 2, canvas.height / 2 + 40);
}

function gameLoop() {
  if (gameOver) {
    showGameOver();
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  movePlayer();
  if (checkCollisions()) {
    gameOver = true;
    clearInterval(scoreTimer);
    showGameOver();
    return;
  }

  drawPoops();
  drawScoreCircle();
  drawPlayer();

  requestAnimationFrame(gameLoop);
}

function resetGame() {
  poopObstacles.length = 0;
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height - player.height * 1.5;
  player.verticalSpeed = 1;
  score = 0;
  gameOver = false;
  spawnPoopObstacle();
  clearInterval(scoreTimer);
  scoreTimer = setInterval(() => { if (!gameOver) score++; }, 1000);
  gameLoop();
}

document.addEventListener("keydown", e => {
  if (gameOver && e.key === "Enter") resetGame();
});

resetGame();
</script>
</body>
</html>
