<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smiley vs Lachende Kakskes</title>
  <style>
    html,body{margin:0;padding:0;background:#111;display:flex;justify-content:center;align-items:center;height:100vh}
    canvas{background:#222;border:2px solid #444}
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx     = canvas.getContext("2d");

/* ---------- CONSTANTEN ---------- */
const SMILEY_SIZE      = 40;
const SPEED_INCREMENT  = 0.15;   // per passage
const MAX_VERTICAL_SPD = 5;      // veiligheidslimiet
const SPAWN_ATTEMPTS   = 30;     // tries om overlap-vrij te plaatsen

/* ---------- INPUT ---------- */
const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup",   e => keys[e.key] = false);

/* ---------- OBJECTEN ---------- */
const player = {
  x: canvas.width / 2 - SMILEY_SIZE / 2,
  y: canvas.height - SMILEY_SIZE * 1.5,
  width : SMILEY_SIZE,
  height: SMILEY_SIZE,
  speed : 3,              // horizontaal
  verticalSpeed: 1,       // startwaarde, groeit langzaam
  emoji : "ðŸ˜Š"
};

const centerCircle = {               // score-cirkel
  x: canvas.width / 2,
  y: canvas.height / 2,
  radius: 50
};

const poopObstacles = [];
let score      = 0;
let scoreTimer = null;
let gameOver   = false;

/* ---------- UTILITIES ---------- */
function startScoreTimer(){
  clearInterval(scoreTimer);
  scoreTimer = setInterval(()=>{ if(!gameOver) score++; },1000);
}
function distance(x1,y1,x2,y2){
  const dx = x1-x2, dy = y1-y2;
  return Math.hypot(dx,dy);
}

/* ---------- SPAWN LOGICA ---------- */
function spawnPoopObstacle(){
  let placed = false, attempts = 0;
  while(!placed && attempts++ < SPAWN_ATTEMPTS){
    const scale   = Math.random()*2 + 1;         // 1Ã—â€“3Ã— smiley
    const size    = SMILEY_SIZE * scale;
    const radius  = size / 2;
    const x = Math.random() * (canvas.width  - size);
    const y = Math.random() * (canvas.height*0.75 - size); // bovenste Â¾

    // Overlap met score-cirkel?
    if(distance(x+radius, y+radius, centerCircle.x, centerCircle.y) <
       radius + centerCircle.radius) continue;

    // Overlap met andere poopjes?
    let overlap = false;
    for(const o of poopObstacles){
      if(distance(x+radius, y+radius, o.x+o.size/2, o.y+o.size/2) <
         radius + o.size/2){ overlap = true; break; }
    }
    if(overlap) continue;

    poopObstacles.push({x,y,size,emoji:"ðŸ’©"});
    placed = true;
  }
}

/* ---------- BEWEGING & COLLISIE ---------- */
function movePlayer(){
  if(keys["ArrowLeft"]||keys["a"]) player.x -= player.speed;
  if(keys["ArrowRight"]||keys["d"])player.x += player.speed;

  player.y -= player.verticalSpeed;

  // boven uit beeld â†’ reset & moeilijker
  if(player.y + player.height < 0){
    player.y = canvas.height;
    player.x = Math.random() * (canvas.width - player.width);

    // spawn 1â€“2 nieuwe kakskes
    const toSpawn = Math.floor(Math.random()*2)+1;
    for(let i=0;i<toSpawn;i++) spawnPoopObstacle();

    // verhoog verticale snelheid zachtjes
    player.verticalSpeed = Math.min(player.verticalSpeed + SPEED_INCREMENT,
                                    MAX_VERTICAL_SPD);
  }

  // schermranden links/rechts
  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
}

function rectCircleCollision(rect,circle){
  const rectCX = rect.x + rect.width /2;
  const rectCY = rect.y + rect.height/2;
  const circCX = circle.x + circle.size/2;
  const circCY = circle.y + circle.size/2;
  const radius = circle.size/2;

  const dx = Math.abs(circCX - rectCX);
  const dy = Math.abs(circCY - rectCY);

  if(dx > rect.width/2 + radius) return false;
  if(dy > rect.height/2+ radius) return false;
  if(dx <= rect.width/2) return true;
  if(dy <= rect.height/2) return true;

  const cornerDistSq = (dx-rect.width/2)**2 + (dy-rect.height/2)**2;
  return cornerDistSq <= radius**2;
}
function checkCollisionWithCenter(){
  return distance(player.x+player.width/2, player.y+player.height/2,
                  centerCircle.x, centerCircle.y)
         < centerCircle.radius + player.width/2;
}
function checkCollisions(){
  if(checkCollisionWithCenter()) return true;
  for(const o of poopObstacles){ if(rectCircleCollision(player,o)) return true; }
  return false;
}

/* ---------- TEKENEN ---------- */
function drawPlayer(){
  ctx.font = "32px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(player.emoji, player.x+player.width/2, player.y+player.height/2);
}
function drawPoops(){
  for(const o of poopObstacles){
    ctx.font = `${o.size}px Arial`;
    ctx.fillText(o.emoji, o.x+o.size/2, o.y+o.size/2);
  }
}
function drawScoreCircle(){
  ctx.beginPath();
  ctx.fillStyle="red";
  ctx.arc(centerCircle.x,centerCircle.y,centerCircle.radius,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.font="24px Arial";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(score,centerCircle.x,centerCircle.y);
}
function showGameOver(){
  ctx.fillStyle="rgba(0,0,0,.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="white";
  ctx.font="40px Arial";
  ctx.textAlign="center";
  ctx.fillText("ðŸ’€ Game Over",canvas.width/2,canvas.height/2-40);
  ctx.font="24px Arial";
  ctx.fillText(`Score: ${score}`,canvas.width/2,canvas.height/2);
  ctx.fillText("Druk op ENTER om opnieuw te spelen",
               canvas.width/2,canvas.height/2+40);
}

/* ---------- GAMELOOP ---------- */
function gameLoop(){
  if(gameOver){ showGameOver(); return; }

  ctx.clearRect(0,0,canvas.width,canvas.height);

  movePlayer();
  if(checkCollisions()){
    gameOver = true;
    clearInterval(scoreTimer);
    showGameOver();
    return;
  }

  drawPoops();
  drawScoreCircle();
  drawPlayer();

  requestAnimationFrame(gameLoop);
}

/* ---------- RESET / INIT ---------- */
function resetGame(){
  poopObstacles.length = 0;
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - player.height*1.5;
  player.verticalSpeed = 1; // reset speed
  score = 0; gameOver=false;
  spawnPoopObstacle();               // eerste obstakel
  startScoreTimer();
  gameLoop();
}
document.addEventListener("keydown",e=>{
  if(gameOver && e.key==="Enter") resetGame();
});
resetGame();
</script>
</body>
</html>
